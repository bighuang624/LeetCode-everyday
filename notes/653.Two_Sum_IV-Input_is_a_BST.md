# Two Sum IV - Input is a BST

## 题目

Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.

**Example 1:**

```
Input: 
    5
   / \
  3   6
 / \   \
2   4   7

Target = 9

Output: True
```

**Example 2:**

```
Input: 
    5
   / \
  3   6
 / \   \
2   4   7

Target = 28

Output: False
```

## 解题思路

第一思路是遍历的同时放入`HashSet`中来确定是否有复合要求的实数对。代码如下：

```java
class Solution {
    public boolean findTarget(TreeNode root, int k) {
        if(root == null)
            return false;
        HashSet<Integer> set = new HashSet<Integer>();
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);
        while(!queue.isEmpty()) {
            int size = queue.size();
            for(int i = 0; i < size; i++) {
                TreeNode cur = queue.poll();
                if(set.contains(k - cur.val))
                    return true;
                set.add(cur.val);
                if(cur.left != null)
                    queue.offer(cur.left);
                if(cur.right != null)
                    queue.offer(cur.right);
            }
        }
        return false;
    }
}
```

## 优化方案

显然上述解法的时间复杂度和空间复杂度都为 O(n)，并且容易看出该解法对所有的树都成立，没有用到 BST 的特性。

下面是一种时间复杂度为 O(n)，但空间复杂度平均为 O(nlogn) 的解法：

```java
class Solution {
    public boolean findTarget(TreeNode root, int k) {
        if(root == null) return false;
    	Stack<TreeNode> l_stack = new Stack<>();
    	Stack<TreeNode> r_stack = new Stack<>();
    	stackAdd(l_stack, root, true);
    	stackAdd(r_stack, root, false);
    	while(l_stack.peek() != r_stack.peek()){
    	    int n = l_stack.peek().val + r_stack.peek().val;
    	    if(n == k){
    		return true;
    	    }else if(n > k){
    		stackNext(r_stack, false);
    	    }else{
		stackNext(l_stack, true);
    	    }
    	}
    	return false;
    }
    
    private void stackAdd(Stack<TreeNode> stack, TreeNode node, boolean isLeft){
    	while(node != null){
    	    stack.push(node);
            node = (isLeft) ? node.left : node.right;
    	}
    }

    private void stackNext(Stack<TreeNode> stack, boolean isLeft){
    	TreeNode node = stack.pop();
    	if(isLeft){
    	    stackAdd(stack, node.right, isLeft);
    	}else{
    	    stackAdd(stack, node.left, isLeft);
    	}
    }
}
```