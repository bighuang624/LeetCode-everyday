# Kth Smallest Element in a Sorted Matrix

## 题目

Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.

Note that it is the kth smallest element in the sorted order, not the kth distinct element.

**Example:**

```
matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

return 13.
```

**Note:**
You may assume k is always valid, 1 ≤ k ≤ n^2.

## 解题思路

全部加入 list 后 sort：

```java
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        for(int[] arr : matrix)
            for(int num : arr)
                list.add(num);
        Collections.sort(list);
        return list.get(k-1);
    }
}
```

## 优化解法

使用 PriorityQueue（最小队列）。先将第一行全部加入队列，然后每次取出一个元素时，将它同一列的下个元素存入队列，重复 k-1 次。再取出的那个元素即为所求。

```java
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        int n = matrix.length;
        PriorityQueue<Tuple> pq = new PriorityQueue<Tuple>();
        for(int j = 0; j <= n-1; j++) pq.offer(new Tuple(0, j, matrix[0][j]));
        for(int i = 0; i < k-1; i++) {
            Tuple t = pq.poll();
            if(t.x == n-1) continue;
            pq.offer(new Tuple(t.x+1, t.y, matrix[t.x+1][t.y]));
        }
        return pq.poll().val;
    }
}

class Tuple implements Comparable<Tuple> {
    int x, y, val;
    public Tuple (int x, int y, int val) {
        this.x = x;
        this.y = y;
        this.val = val;
    }
    
    @Override
    public int compareTo (Tuple that) {
        return this.val - that.val;
    }
}
```

## 最佳解法

二分搜索：

```java
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        int lo = matrix[0][0], hi = matrix[matrix.length - 1][matrix[0].length - 1] + 1;//[lo, hi)
        while(lo < hi) {
            int mid = lo + (hi - lo) / 2;
            int count = 0,  j = matrix[0].length - 1;
            for(int i = 0; i < matrix.length; i++) {
                while(j >= 0 && matrix[i][j] > mid)    // 找到比 mid 小的元素个数
                    j--;
                count += (j + 1);
            }
            if(count < k) lo = mid + 1;
            else hi = mid;
        }
        return lo;
    }
}
```
